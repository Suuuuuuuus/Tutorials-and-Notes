\documentclass[UTF8]{book}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{makeidx}
\usepackage{enumitem}
\usepackage{rotating} 
\usepackage{yhmath}
\usepackage{textcomp,booktabs}
\usepackage[usenames,dvipsnames]{color}
\usepackage{colortbl}
\usepackage{makecell}
\usepackage{gensymb}
\usepackage{cancel}
\usepackage{graphicx}
\usepackage{pifont}
\usepackage[all,pdf]{xy}
\usepackage{exscale}
\usepackage{blindtext}
\usepackage{hyperref}
\hypersetup{
colorlinks=true,
linkcolor=black
}
\usepackage{nameref}
\usepackage{relsize}
\usepackage{titlesec}
\usepackage{ifthen}
\usepackage{array}
\usepackage[flushleft]{threeparttable}
\usepackage{diagbox}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{bbm}
\usepackage{ulem}
\usepackage{xcolor}
\usepackage{color}
\usepackage{mathptmx}
\usepackage{amssymb}
\usepackage{geometry}
\geometry{a4paper, left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm}
%\geometry{b5paper, left=1.6cm,right=2cm,top=2cm,bottom=2cm}
\usepackage{mathrsfs}
\usepackage{tikz,tkz-euclide}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes,arrows}
\usepackage{esvect}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhead{} % clear all fields 
\cfoot{}
\fancyhead[LE,RO]{\thepage} 
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\linespread{1.4}
\date{}
\graphicspath{ {../Graphs} }
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  backgroundcolor=\color{gray!20!white}
}
\definecolor{codegray}{gray}{0.8}
\newcommand{\code}[1]{\colorbox{codegray}{\texttt{#1}}}
%通用：
\newcounter{mylabelcounter}
\makeatletter
\newcommand{\labeltext}[2]{%
#1\refstepcounter{mylabelcounter}%
\immediate\write\@auxout{%
  \string\newlabel{#2}{{1}{\thepage}{{\unexpanded{#1}}}{mylabelcounter.\number\value{mylabelcounter}}{}}%
}%
}
%Xsum
\DeclareFontFamily{U} {cmex}{}
\DeclareFontShape{U}{cmex}{m}{n}{
  <-6> cmex5
  <6-7> cmex6
  <7-8> cmex7
  <8-9> cmex8
  <9-10> cmex9
  <10-12> cmex10
  <12-> cmex12}{}
\DeclareSymbolFont{Xcmex} {U} {cmex}{m}{n}
\DeclareMathSymbol{\Xdsum}{\mathop}{Xcmex}{88}
\DeclareMathSymbol{\Xtsum}{\mathop}{Xcmex}{80}
\DeclareMathOperator*{\Xsum}{\mathchoice{\Xdsum}{\Xtsum}{\Xtsum}{\Xtsum}}
%Xsum
%choice
\newcommand{\fourch}[4]{%~\hfill(\qquad)\\
\begin{tabular}{*{4}{@{}p{0.25\textwidth}}}(A)~#1 & (B)~#2 & (C)~#3 & (D)~#4\end{tabular}}
\newcommand{\twoch}[4]{%~\hfill(\qquad)\\
\begin{tabular}{*{2}{@{}p{0.5\textwidth}}}(A)~#1 & (B)~#2\end{tabular}\\\begin{tabular}{*{2}{@{}p{0.5\textwidth}}}(C)~#3 & (D)~#4\end{tabular}}
\newcommand{\onech}[4]{%~\hfill(\qquad)\\
(A)~#1 \\ (B)~#2 \\ (C)~#3 \\ (D)~#4}
 
\newlength\widthcha
\newlength\widthchb
\newlength\widthchc
\newlength\widthchd
\newlength\widthch
\newlength\tabmaxwidth
\setlength\tabmaxwidth{1\textwidth}
\newlength\fourthtabwidth
\setlength\fourthtabwidth{0.25\textwidth}
\newlength\halftabwidth
\setlength\halftabwidth{0.5\textwidth}
\newcommand{\choice}[4]{\settowidth\widthcha{AM.#1}\setlength{\widthch}{\widthcha}
    \settowidth\widthchb{BM.#2}
    \ifthenelse{\widthch<\widthchb}{\setlength{\widthch}{\widthchb}}{}
    \settowidth\widthchb{CM.#3}
    \ifthenelse{\widthch<\widthchb}{\setlength{\widthch}{\widthchb}}{}
    \settowidth\widthchb{DM.#4}
    \ifthenelse{\widthch<\widthchb}{\setlength{\widthch}{\widthchb}}{}
    \ifthenelse{\widthch<\fourthtabwidth}{\fourch{#1}{#2}{#3}{#4}}
    {\ifthenelse{\widthch<\halftabwidth\and\widthch>\fourthtabwidth}{\twoch{#1}{#2}{#3}{#4}}
        {\onech{#1}{#2}{#3}{#4}}}}
%choice
% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
morekeywords={self},              % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=single,                         % Any extra options here
showstringspaces=false
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}
%%%%%
% Bash style for highlighting
\newcommand\bashstyle{\lstset{
language=bash,
basicstyle=\ttm\normalsize,
tabsize=4,
morekeywords={self, head, tail, uniq, sort, grep, cat, cut, echo, wc, cp, rm, mkdir, cd, nano, man, ls, history, bash, rmdir, find},              % Add keywords here
keywordstyle=\color{deepblue}\normalsize\bfseries,
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=single,                         % Any extra options here
showstringspaces=false
}}


% Python environment
\lstnewenvironment{bash}[1][]
{
\bashstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\bashexternal[2][]{{
\bashstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\bashinline[1]{{\bashstyle\lstinline!#1!}}
%%%%%
\newcommand{\dollar}{\mbox{\textdollar}}
\newcommand{\dps}[1]{\ensuremath{\displaystyle{#1}}}
\newcommand\ffrac[2]{\ensuremath{\dfrac{\;#1\;}{\;#2\;}}}
\newcommand{\comma}{\, \; \;\mathclap{\text{，}}} %用于mathmode中的逗号
\newcommand{\semicolon}{\, \; \;\mathclap{\text{；}}} %用于mathmode中的分号
\newcommand{\pl}{\phantom{l}} %用来占位
\newcommand{\un}{\ding{172}}
\newcommand{\deux}{\ding{173}}
\newcommand{\trois}{\ding{174}}
\newcommand{\quatre}{\ding{175}}
\newcommand{\et}{&}
\newcommand{\f}{^2}
\newcommand{\xz}{(\qquad)}
\newcommand{\tk}{\underline{\qquad\qquad}}
%高等数学：
\renewcommand{\d}{\,\mathrm{d}}
\newcommand{\dt}{\,\mathrm{d}t}
\newcommand{\dr}{\,\mathrm{d}r}
\newcommand{\du}{\,\mathrm{d}u}
\newcommand{\dv}{\,\mathrm{d}v}
\newcommand{\dx}{\,\mathrm{d}x}
\newcommand{\dy}{\,\mathrm{d}y}
\newcommand{\dz}{\,\mathrm{d}z}
\newcommand{\df}{\,\mathrm{d}f}
\newcommand{\bigmid}{\, \bigg | \,} %用于集合中有分数的情况
\newcommand\matharr{\tikz[baseline=-0.4ex]\draw[-stealth] (0,0) -- + (3mm,0);} %用于下标中的右箭头
\newcommand\textarr{\; \tikz[baseline=-0.55ex]\draw[-stealth] (0,0) -- + (4mm,0);} %用于文本中的右箭头，注意用占位符调整前后间距
\newcommand{\limite}[2]{\ensuremath{\lim\limits_{#1\matharr #2}}} %#1趋向于#2
\newcommand{\dlimite}[4]{\ensuremath{\displaystyle{\lim_{\substack{ \phantom{l}#1\matharr #2\phantom{l} \\ #3\matharr #4}}}}} %#重极限：1趋向于#2，#3趋向于#4，phantom{l}用来占位
\newcommand{\neighbr}{\ensuremath{\mathring{U}(x_0\comma \delta)}} %去心邻域U
\newcommand{\neighbor}{\ensuremath{U(x_0\comma \delta)}} %邻域U
\newcommand{\tikzrm}[1]{
	\fill[white] #1 circle(1.5pt);
	\draw #1 circle(1.5pt);
}
\newcommand{\derivee}[4]{
	\ffrac{\,\mathrm{d}^{#1}#2}{\,\mathrm{d}#3^{#4}}
}
\newcommand{\intscript}[2]{\biggl.\biggr|_{\, #2}^{\, #1}} %求出原函数以后代入的积分上下限
\newcommand{\dint}[2]{\ensuremath{\displaystyle{\int_{#2}^{#1}}}}
\newcommand{\diint}[4]{\ensuremath{\displaystyle{\int_{#2}^{#1}\int_{#4}^{#3}}}}
\newcommand{\bint}{\mathlarger{\int}} %用于将幂次上的积分号放大
\newcommand{\exiint}{\ensuremath{\!\!\!}} %用于缩短累次积分中积分号的距离
\newcommand{\fxy}{\ensuremath{f(x\comma y)}}
\newcommand{\xoyo}{\ensuremath{(x_0\comma y_0)}}
\newcommand{\series}{\ensuremath{\dps{\Xsum_{n=1}^\infty}}} %级数
\newcommand{\serieso}{\ensuremath{\dps{\Xsum_{n=0}^\infty}}} %0开始的级数
%线性代数：
\newcommand{\pa}{\ensuremath{\pmb{A}}}
\newcommand{\pb}{\ensuremath{\pmb{B}}}
\newcommand{\pc}{\ensuremath{\pmb{C}}}
\newcommand{\po}{\ensuremath{\pmb{O}}}
\newcommand{\pp}{\ensuremath{\pmb{P}}}
\newcommand{\pq}{\ensuremath{\pmb{Q}}}
\newcommand{\pe}{\ensuremath{\pmb{E}}}
\newcommand{\pal}{\ensuremath{\pmb{\alpha}}}
\newcommand{\pbe}{\ensuremath{\pmb{\beta}}}
\newcommand{\pxi}{\ensuremath{\pmb{\xi}}}
\newcommand{\pet}{\ensuremath{\pmb{\eta}}}
\renewcommand{\t}{\ensuremath{^\mathrm{T}}}
\newcommand\laarr{\qquad\tikz\draw[-stealth] (0,0) -- + (7mm,0);\qquad} %用于矩阵中的初等变换
\newcommand{\laarrt}[1]{\qquad\tikz\draw[-stealth] (0,0) -- (4mm,0) node[above]{#1}--+ (4mm,0);\qquad} %初等变换上带字
%概率：
\newcommand{\XY}{\ensuremath{(X\comma Y)}}
\newcommand{\Cov}{\ensuremath{\mathrm{Cov}}}
\newcommand{\cip}{\tikz[baseline=-0.55ex]\draw[-stealth] (0,0) -- (2mm,0) node[above]{$\;\;P$}--+ (4mm,0);\;} %依概率收敛
\newcommand{\seriesn}{\ensuremath{\dps{\Xsum_{i=1}^n}}} %1开始到n的连续求和
\begin{document}
\kaishu
\begin{center}
\Large{Unix Shell Software Carpentry Notes}
\end{center}
\begin{itemize}
\item The Unix shell is both a \textcolor{magenta}{command-line interface (CLI)} and a scripting language. The most popular Unix shell is \textcolor{magenta}{Bash},  the default shell on most modern implementations of Unix and in most packages that provide Unix-like tools for Windows.
\item \code{ls} prints the names of the files and directories in the current directory. 
\item About \code{ls}:
\begin{itemize}
	\item The \code{ls --help} option displays more information on how to use \code{ls}, whereas \code{man ls} turns the terminal into a page with a description of \code{ls} and its options.
\begin{itemize}
	\item Use \code{$\uparrow$} and \code{$\downarrow$} to move line-by-line.
	\item Use \code{B} and \code{Space} to skip up and down by a full page.
	\item Use \code{/} followed by the character or word to search. If there are multiple hits, use \code{N} and \code{Shift + N} to move forward and backward.
	\item Use \code{Q} to quit the \code{man} page.
\end{itemize}
	\item \code{-F} tells \code{ls} to classify the output by adding a marker to file and directory names to indicate what they are:
\begin{itemize}
	\item \code{/}: directory.
	\item \code{@}: link.
	\item \code{*}: executable.
\end{itemize}
Any names in the output that don’t have a classification symbol are plain old files.
	\item \code{-l} makes \code{ls} use a long listing format, showing not only the file/directory names but also additional information, such as the file size and the time of its last modification. If one uses both \code{-h} and \code{-l}, then the file size becomes human readable (e.g.: displaying \code{5.3K} instead of \code{5369}).
	\item \code{-t} lists items by time of last change rather than in alphabetical order by default.
	\item \code{-r} lists the contents of a directory in reverse order.
	\item \code{-s} displays the size of files and directories alongside the names.
	\item \code{-S} sorts the files and directories by size.
	\item \code{-R} lists all nested subdirectories within a directory.
	\item \code{-a}\footnote{Note that in most command line tools, multiple options can be combined with a single \code{-} and no spaces between the options (e.g.: \code{ls -F -a} is equivalent to \code{ls -Fa}).} lists ALL directories, where
	\begin{itemize}
		\item \code{./} refers to the current working directory.
		\item \code{../} refers to the parent directory.
	\end{itemize}
	One may also see other files starting with a dot (e.g.: \code{.bash\_profile}). These files usually contain shell (or other programs) configuration settings. The prefix \code{.} is used to prevent these configuration files from cluttering the terminal when a standard \code{ls} command is used.
	\item \code{ls} can be given multiple paths at once.
\end{itemize}
\code{ls Desktop} can also output the list of contents of a different directory. Pressing \code{Tab} twice more after a complete directory to see all of those files in the target directory. 
\item About \code{cd}:
\begin{itemize}
	\item \code{cd -} allows one to move to the previous directory.
	\item \code{cd $\sim$} allows one to move to the home directory\footnote{In Unix, the directory \code{/mnt/c} is equivalent to \code{C:} on Windows.}.
	\item \code{cd ../..} allows one to move back up two levels.
	\item \code{cd /} allows one to move back to the root directory.
\end{itemize}
\item About \code{mkdir}:
\begin{itemize}
	\item \code{-p} allows \code{mkdir} to create nested subdirectories. Note that Bash does not accept spaces within filenames and one needs to surround the name in double quotes (\code{""}) instead.
\end{itemize}
\item About \code{nano}\footnote{\code{nano} is a text editor that is the simplest. Check \code{Emacs}, \code{Vim}, \code{Gedit}, \code{Notepad++} for more information.}:
\begin{itemize}
	\item \code{nano draft.txt} creates a new file called \code{draft.txt} and uses \code{nano} to edit it, whereas \code{touch draft.txt} simply creates the new file.
	\item \code{Ctrl + O} followed by \code{Enter} saves the file, and \code{Ctrl + X} quits the editor.
\end{itemize}
\item About \code{mv}:
\begin{itemize}
	\item The \code{mv} command can move a file to another directory or simply rename a file if the previous and new files are in the same directory.
	\item \code{mv} silently overwrites any existing file with the same name. An additional option \code{-i} can be used to make \code{mv} ask for confirmation before overwriting.
	\item \code{mv thesis/quotes.txt .} moves the \code{quotes.txt} file to the current directory, as per explained before.
\end{itemize}
\item About \code{cp}:
\begin{itemize}
	\item The \code{cp} command copies a file instead of moving it. If it receives multiple arguments, it expects the last argument to be a directory in which the former files are to be moved.
	\item \code{-r} copies a directory and all its contents.
\end{itemize}
\item About \code{rm}:
\begin{itemize}
	\item \code{-i} brings up an interactive session that asks our permission before deleting a file. One needs to note that there is \textcolor{blue}{no recycle bin in Unix}, so the deletion is always permanent.
	\item \code{-r} removes a directory and all its contents.
\end{itemize}
\item A \textcolor{magenta}{regular expression} specifies a set of strings required for a particular purpose. Operators and quantifiers involve:
\begin{itemize}
	\item \code{()} is for grouping.
	\item \code{?} indicates \textcolor{blue}{zero or one occurrences} of the preceding element\footnote{In Bash, \code{?} does not operate on the previous character.}.
	\item \code{*} indicates \textcolor{blue}{zero or more occurrences} of the preceding element\footnote{In Bash, \code{*} does not operate on the previous character.}.
	\item \code{+} indicates \textcolor{blue}{one or more occurrences} of the preceding element.
	\item \code{\{n\}} indicates the preceding item being matched \textcolor{blue}{exactly $n$ times}.
	\item \code{\{min,\}} indicates the preceding item being matched \textcolor{blue}{$min$ or more times}.
	\item \code{\{,max\}} indicates the preceding item being matched \textcolor{blue}{$max$ or less times}.
	\item \code{\{min, max\}} indicates the preceding item being matched \textcolor{blue}{more than $min$ but less than $max$ times}.
	\item \code{{[]}} matches a \textcolor{blue}{single character that is contained within the brackets} (e.g.: {[abcx-z]} matches 'a', 'b', 'c', 'x', 'y', or 'z'). A starting \code{\^{}} at the beginning within the bracket matches a \textcolor{blue}{single character other than the specified characters}.
	\item \code{\^{}} matches the \textcolor{blue}{starting position}.
	\item \code{\$} matches the \textcolor{blue}{ending position}.
	\item \code{$\cdot$} is known as a \textcolor{magenta}{wildcard}\footnote{Note that in Bash, the wildcard character is \code{*} rather than \code{$\cdot$}.}. It matches any character. For example,
	\begin{itemize}
		\item \code{a.b} matches \code{acb} or \code{aob}.
		\item \code{a.*b} matches \code{acb} or \code{aerb}.
	\end{itemize}
\end{itemize}
\item About \code{wc}:
\begin{itemize}
	\item The \code{wc} commands output the number of \textcolor{blue}{lines, words, and characters} in files, which can be specified by \code{-l}, \code{-w}, and \code{-m}.
\end{itemize}
\item About \code{cat}:
\begin{itemize}
	\item \code{cat} prints the contents of files one after another, but it has the disadvantage that it always dumps the whole file onto your screen. Instead, one can use \code{less}.
\end{itemize}
\item About \code{sort}:
\begin{itemize}
	\item The \code{sort} commands sort the contents of a file in \textcolor{blue}{alphanumerical} order. Note that the command does not change the original file but simply sends the sorted result to the screen.
	\item \code{-n} specifies a \textcolor{blue}{numerical sort} rather than the default alphanumerical sort.
\end{itemize}
\item About \code{echo}；
\begin{itemize}
	\item The \code{echo} command prints strings.
	\item Two operators:
	\begin{itemize}
		\item \code{>} tells the shell to overwrite the output to a file.
		\item \code{>>} tells the shell to append the output to a file.
	\end{itemize}
\end{itemize}
\item About \code{cut}:
\begin{itemize}
	\item The \code{cut} command is used to remove certain sections of each line in the file. It expects the lines to be separated into columns by a \code{Tab} character (or generally speaking, a \textcolor{magenta}{delimiter}).
	\item \code{-d} specifies a delimiter.
	\item \code{-f} specifies the field we want to extract.
\end{itemize}
\item About \code{uniq}:
\begin{itemize}
	\item The \code{uniq} command filters out adjacent\footnote{It has to be used together with \code{sort}} matching lines in a file. 
	\item \code{-c} gives a count of the number of times a line occurs in its input.
\end{itemize}
\item About loops in Bash:
\begin{itemize}
	\item A for loop can look like
	\begin{bash}
for filename in basilisk.dat minotaur.dat unicorn.dat
do
	head -n 2 $filename | tail -n 1
done
	\end{bash}
	%$
	Instead, one can write this code in one line by
	\begin{bash}
for f in *.dat; do head -n 2 $f | tail -n 1; done 
	\end{bash}
	%$
	where \code{;} is used to separate arguments. One should note that if the filename contains a space, then it is necessary to put \code{""} around both the loop body and the loop element.
\end{itemize}
\item About \code{history}:
\begin{itemize}
	\item The \code{history} command gets a list of the last few hundred commands that have been executed, and then to use \code{!123} to execute again the 123 command.
	\item \code{Ctrl + R} enters a history search mode 'reverse-i-search' and finds the most recent command in the history. Press \code{Ctrl + R} again can search for earlier matches. One can then edit the line by \code{$\leftarrow$} and \code{$\rightarrow$} before hit \code{Enter} to run the command again.
	\item \code{!!} retrieves the immediately preceding command, just as \code{$\uparrow$}.
	\item \code{!\$} retrieves the last word of the last command (e.g.: one may use \code{less !\$} to look at the previous file).
\end{itemize}
\item About shell scripts:
\begin{itemize}
	\item By creating a shell script via \code{nano tmp.sh} and then put commands in it, one can reuse the codes easily by \code{bash tmp.sh}.
	\item It is also possible to require inputs from the prompt. For example, let the file \code{bash tmp.sh} be
	\begin{bash}
head -n 15 "$1" | tail -n 5
	\end{bash}
	%$
	Here \code{\$1} means the first argument on the command line\footnote{The double quotes here is just in case the filename happens to contain any spaces.}. Now, one can run the script by
	\begin{bash}
bash tmp.sh file.txt
	\end{bash}
	Of course, one can add \code{\$2}, \code{\$3}, etc. to allow more inputs in the command line. However, one should add comments (by \code{\#}) to indicate what to type in the command to improve readability.
	\item The special syntax \code{\$@} is to handle the case how many files there are is unknown ex ante. Again, the character is usually surrounded by double quotes.
	\item One can do
	\begin{bash}
history | tail -n 5 > his.sh
	\end{bash}
	to save the last 5 commands in the prompt, including the \code{history} command as well. Only can one reuse these codes before removing the preceding numbers in each line and the final \code{history} command.
	\item \code{-x} runs the script in debug mode, which prints out each command as it is running.
\end{itemize}
\item About \code{grep}:
\begin{itemize}
	\item \code{-w} restricts to lines containing the word on its own rather than all strings containing it. It can also search for phrases:
	\begin{bash}
grep -w "is not" haiku.txt
	\end{bash}
	\item \code{-n} also outputs the numbers the lines that match.
	\item \code{-i} makes the search case-insensitive.
	\item \code{-v} inverts a search.
	\item \code{-r} can recursively search for a pattern through a set of files in subdirectories.
	\begin{bash}
grep -r Yesterday .
	\end{bash}
	\item \code{-E} enables one to select regular expressions:
	\begin{bash}
grep -E "^.o" haiku.txt
	\end{bash}
	This command selects any line whose second character is 'o'. Note that we need to put the regular expression inside double quotes to prevent the shell from trying to interpret it.
	\item \code{-o} prints only the matched (non-empty) parts of a matching line with each such part on a separate output line.
	\item \code{-c} reports only the number of lines matched.
\end{itemize}
\item About \code{find}:
\begin{itemize}
	\item The \code{find} command finds files and directories.
	\item \code{-type d} finds directories in a specified directory, whereas \code{-type f} finds files.
	\item \code{-name} finds files by their name. However, we expect to use the following command to find all \code{.txt} files in the current working directory (specified by \code{$\cdot$})
	\begin{bash}
find . -name *.txt
	\end{bash}
	but the shell \textcolor{blue}{expands wildcard characters like \code{*} before commands run}. Since \code{*.txt} in the current working directory expands to \code{./numbers.txt}, the command we actually ran was:
	\begin{bash}
find . -name numbers.txt
	\end{bash}
	To solve this, again, we surround the argument by double quotes.
	\item Though the \code{find} command is kind of similar to that of \code{ls}, it's much more useful in certain ways. For example, one wants to count the number of lines of all \code{.txt} files that span several directories, one can write
	\begin{bash}
	wc -l $(find . -name "*.txt")
	\end{bash}
	%$
	It first executes the \code{find} command and then the \code{wc} command.
\end{itemize}
\end{itemize}
\end{document}
